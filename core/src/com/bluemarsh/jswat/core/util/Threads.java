/*
 * The contents of this file are subject to the terms of the Common Development
 * and Distribution License (the License). You may not use this file except in
 * compliance with the License.
 *
 * You can obtain a copy of the License at http://www.netbeans.org/cddl.html
 * or http://www.netbeans.org/cddl.txt.
 *
 * When distributing Covered Code, include this CDDL Header Notice in each file
 * and include the License file at http://www.netbeans.org/cddl.txt.
 * If applicable, add the following below the CDDL Header, with the fields
 * enclosed by brackets [] replaced by your own identifying information:
 * "Portions Copyrighted [year] [name of copyright owner]"
 *
 * The Original Software is the JSwat Core Module. The Initial Developer of the
 * Software is Nathan L. Fiedler. Portions created by Nathan L. Fiedler
 * are Copyright (C) 2002-2010. All Rights Reserved.
 *
 * Contributor(s): Nathan L. Fiedler.
 *
 * $Id$
 */
package com.bluemarsh.jswat.core.util;

import com.sun.jdi.ThreadGroupReference;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.VMDisconnectedException;
import com.sun.jdi.VirtualMachine;
import java.util.EmptyStackException;
import java.util.Iterator;
import java.util.List;
import java.util.Stack;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.openide.util.NbBundle;

/**
 * Provides utility methods for handling threads.
 *
 * @author  Nathan Fiedler
 */
public class Threads {

    /** The thread pool, if created, for running background tasks. */
    private static ExecutorService threadPool;

    /**
     * Creates a new instance of Threads.
     */
    private Threads() {
    }

    /**
     * Finds the thread in debuggee whose name or identifier is equal to
     * that which is given.
     *
     * @param  vm  debuggee virtual machine.
     * @param  id  thread identifier (decimal number or name).
     * @return  ThreadReference, or null if not found.
     */
    public static ThreadReference findThread(VirtualMachine vm, String id) {
        List<ThreadReference> threads = vm.allThreads();
        Iterator<ThreadReference> iter = threads.iterator();
        ThreadReference thread = null;
        try {
            // Compare the identifier as if it were a number.
            long threadID = Long.parseLong(id);
            while (iter.hasNext()) {
                ThreadReference th = iter.next();
                if (th.uniqueID() == threadID) {
                    thread = th;
                    break;
                }
            }

        } catch (NumberFormatException nfe) {
            // Compare the identifier as if it were a name.
            while (iter.hasNext()) {
                ThreadReference th = iter.next();
                if (th.name().equals(id)) {
                    thread = th;
                    break;
                }
            }
        }
        return thread;
    }

    /**
     * Return an identifier for the given thread. This is generally the
     * thread name, if it has one. Otherwise it is the unique identifier
     * generated by JDI for the thread object reference.
     *
     * @param  thread  thread for which to return identifier.
     * @return  identifier for thread.
     */
    public static String getIdentifier(ThreadReference thread) {
        String id = null;
        try {
            id = thread.name();
        } catch (VMDisconnectedException vmde) {
            // This can happen in breakpoints that occur very near the
            // time the debuggee is exiting (e.g. class and trace events).
            // Fall through to the default handler, as getting the
            // unique identifier is always safe.
        }
        if (id == null || id.isEmpty()) {
            id = String.valueOf(thread.uniqueID());
        }
        return id;
    }

    /**
     * Returns the thread pool for running tasks in the background.
     * If the service has not yet been created, or if the existing
     * service has been shut down, then a new service will be created.
     *
     * @return  cached thread pool.
     */
    public synchronized static ExecutorService getThreadPool() {
        if (threadPool == null || threadPool.isShutdown()) {
            threadPool = Executors.newCachedThreadPool();
        }
        return threadPool;
    }

    /**
     * Creates an iterator over the thread groups that are contained in
     * the given set of thread groups. The initial set itself will also
     * be returned. The groups are returned in depth first order.
     *
     * @param  groups  initial set of groups to iterate.
     * @return  thread group iterator.
     */
    public static Iterator<ThreadGroupReference> iterateGroups(
            List<ThreadGroupReference> groups) {
        return new ThreadGroupIterator(groups);
    }

    /**
     * Return a one-word description of the thread status.
     *
     * @param  thread  thread from which to get status.
     * @return  string description of status.
     */
    public static String threadStatus(ThreadReference thread) {
        String desc;
        switch (thread.status()) {
            case ThreadReference.THREAD_STATUS_MONITOR:
                desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Monitor");
                break;
            case ThreadReference.THREAD_STATUS_RUNNING:
                desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Running");
                break;
            case ThreadReference.THREAD_STATUS_SLEEPING:
                desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Sleeping");
                break;
            case ThreadReference.THREAD_STATUS_WAIT:
                desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Waiting");
                break;
            case ThreadReference.THREAD_STATUS_ZOMBIE:
                desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Zombie");
                break;
            case ThreadReference.THREAD_STATUS_NOT_STARTED:
                desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_NotStarted");
                break;
            default:
                desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Unknown");
                break;
        }
        return desc;
    }

    /**
     * Class ThreadGroupIterator has special functionality for iterating
     * over a list of thread group references. Since thread groups are
     * often assembled in trees, this iterator uses a stack to traverse
     * that tree in depth-first order.
     *
     * @author  Nathan Fiedler
     */
    private static class ThreadGroupIterator implements Iterator<ThreadGroupReference> {

        /** Stack of thread group iterators. */
        private Stack<Iterator<ThreadGroupReference>> stack =
                new Stack<Iterator<ThreadGroupReference>>();

        /**
         * Constructs a new ThreadGroupIterator with an initial set
         * of thread group iterators.
         *
         * @param  groups  ThreadGroup list.
         */
        ThreadGroupIterator(List<ThreadGroupReference> groups) {
            push(groups);
        }

        @Override
        public boolean hasNext() {
            return !stack.isEmpty();
        }

        @Override
        public ThreadGroupReference next() {
            // Ask the top iterator for the next thread group reference.
            ThreadGroupReference group = peek().next();
            // If this group has more groups, add them to the stack.
            push(group.threadGroups());
            // Return the thread group.
            return group;
        }

        /**
         * Looks at the object at the top of this stack without removing
         * it from the stack.
         *
         * @return  First iterator on the stack, or null if none.
         */
        private Iterator<ThreadGroupReference> peek() {
            try {
                return stack.peek();
            } catch (EmptyStackException ese) {
                return null;
            }
        }

        /**
         * Push the given list of thread group iterators onto the stack.
         *
         * @param  groups  List of ThreadGroup iterators.
         */
        private void push(List<ThreadGroupReference> groups) {
            // Add this list's iterator to the stack.
            stack.push(groups.iterator());
            // While the top iterator is empty, pop it off the stack.
            // This ensures that the top iterator has something to iterate.
            while (!stack.isEmpty() && !peek().hasNext()) {
                stack.pop();
            }
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
}
