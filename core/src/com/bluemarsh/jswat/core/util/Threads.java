/*
 *                     Sun Public License Notice.
 *
 * The contents of this file are subject to the Sun Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. A copy of the License is available at
 * http://www.sun.com/
 *
 * The Original Code is the JSwat Core Module. The Initial Developer of the
 * Original Code is Nathan L. Fiedler. Portions created by Nathan L. Fiedler
 * are Copyright (C) 2002-2006. All Rights Reserved.
 *
 * Contributor(s): Nathan L. Fiedler.
 *
 * $Id: Threads.java 15 2007-06-03 00:01:17Z nfiedler $
 */

package com.bluemarsh.jswat.core.util;

import com.sun.jdi.ThreadReference;
import com.sun.jdi.VMDisconnectedException;
import com.sun.jdi.VirtualMachine;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.openide.util.NbBundle;

/**
 * Provides utility methods for handling threads.
 *
 * @author  Nathan Fiedler
 */
public class Threads {
    /** The thread pool, if created, for running background tasks. */
    private static ExecutorService threadPool;

    /**
     * Creates a new instance of Threads.
     */
    private Threads() {
    }

    /**
     * Finds the thread in debuggee whose name or identifier is equal to
     * that which is given.
     *
     * @param  vm  debuggee virtual machine.
     * @param  id  thread identifier (decimal number or name).
     * @return  ThreadReference, or null if not found.
     */
    public static ThreadReference findThread(VirtualMachine vm, String id) {
        List threads = vm.allThreads();
        Iterator iter = threads.iterator();
        ThreadReference thread = null;
        try {
            // Compare the identifier as if it were a number.
            long threadID = Long.parseLong(id);
            while (iter.hasNext()) {
                ThreadReference th = (ThreadReference) iter.next();
                if (th.uniqueID() == threadID) {
                    thread = th;
                    break;
                }
            }

        } catch (NumberFormatException nfe) {
            // Compare the identifier as if it were a name.
            while (iter.hasNext()) {
                ThreadReference th = (ThreadReference) iter.next();
                if (th.name().equals(id)) {
                    thread = th;
                    break;
                }
            }
        }
        return thread;
    }

    /**
     * Return an identifier for the given thread. This is generally the
     * thread name, if it has one. Otherwise it is the unique identifier
     * generated by JDI for the thread object reference.
     *
     * @param  thread  thread for which to return identifier.
     * @return  identifier for thread.
     */
    public static String getIdentifier(ThreadReference thread) {
        String id = null;
        try {
            id = thread.name();
        } catch (VMDisconnectedException vmde) {
            // This can happen in breakpoints that occur very near the
            // time the debuggee is exiting (e.g. class and trace events).
            // Fall through to the default handler, as getting the
            // unique identifier is always safe.
        }
        if (id == null || id.length() == 0) {
            id = String.valueOf(thread.uniqueID());
        }
        return id;
    }

    /**
     * Returns the thread pool for running tasks in the background.
     * If the service has not yet been created, or if the existing
     * service has been shut down, then a new service will be created.
     *
     * @return  cached thread pool.
     */
    public synchronized static ExecutorService getThreadPool() {
        if (threadPool == null || threadPool.isShutdown()) {
            threadPool = Executors.newCachedThreadPool();
        }
        return threadPool;
    }

    /**
     * Return a one-word description of the thread status.
     *
     * @param  thread  thread from which to get status.
     * @return  string description of status.
     */
    public static String threadStatus(ThreadReference thread) {
        String desc;
        switch (thread.status()) {
        case ThreadReference.THREAD_STATUS_MONITOR:
            desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Monitor");
            break;
        case ThreadReference.THREAD_STATUS_RUNNING:
            desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Running");
            break;
        case ThreadReference.THREAD_STATUS_SLEEPING:
            desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Sleeping");
            break;
        case ThreadReference.THREAD_STATUS_WAIT:
            desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Waiting");
            break;
        case ThreadReference.THREAD_STATUS_ZOMBIE:
            desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Zombie");
            break;
        case ThreadReference.THREAD_STATUS_NOT_STARTED:
            desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_NotStarted");
            break;
        default:
            desc = NbBundle.getMessage(Threads.class, "CTL_Thread_Status_Unknown");
            break;
        }
        return desc;
    }
}
